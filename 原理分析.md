## React 中同构SSR 原理梳理
#### csr，ssr和同构
#### csr
  客户端渲染： 客户端渲染，页面初始加载的 HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定,详情 见
  ![1](/images/csr.jpg)
#### ssr
  服务端渲染： 用户请求服务器。 服务器上直接生成html内容 并返回给浏览器 服务端渲染来，页面内容由server 端生成 一版来说服务端渲染页面的交互能力是有限，如果实现复杂的交互就需要引入JavaScript 文件来辅助实现。 服务端渲染这个概念使用任何后端语言
  ![1](/images/ssr.jpg)

#### 同构
同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互
![1](/images/1-3.jpg)


#### ssr 实现本质上是因为虚拟dom 产生
在ssr 中同一份代码执行两次， 在浏览器执行一次 在 node环境执行一次。 但是在Node环境中是没有DOM 这个概念的 如果你的React 代码存在操作DOM 代码在Node 服务端执行就会报错

但是 React 框架 引入了虚拟dom 概念， 虚拟DOM 是真实DOM的一个JavaScript对象映射， React 在操作页面的时候并不是直接操作DOM,而是操作虚拟DOM 也就是操作js对象，这就使得ssr变成了可能
在服务端环境我们把虚拟DOM 映射成字符串输出，在客户端我们把虚拟DOM 映射成真实DOM 完成页面挂载

#### 服务端路由 和客户端路由的差异
同一份代码指的是我们写的各个组件代码，在同构中，只有组件代码是可以公用的，而路由代码是没办法公用，因为 服务端是根据请求路径找到路由组件，客户端是通过浏览器网址，找到路由组件，这是两套机制

1. 客户端路由
```
  const App = () => {
  return (
    <Provider store={store}>
      <BrowserRouter>
        {/* {Routes} */}
        <div>
          {/* {
            routes.map(route => (
              <Route {...route} />
            ))
          } */}
          {renderRoutes(routes)}
        </div>

      </BrowserRouter>
    </Provider>

  )
}
ReactDOM.hydrate(<App />, document.getElementById('root'))
```
使用的是BrowserRouter
2. 服务端路由

```
    const content = renderToString((
    <Provider store={store}>
      <StaticRouter context={context} location={req.path}>
        {/* {Routes} */}
        <div>
          {/* {
            routes.map(route => (
              <Route {...route} />
            ))
          } */}
          {renderRoutes(routes)}
        </div>
      </StaticRouter>
    </Provider>
  ))
```

#### webpack 打包配置的差异

#### SSR中异步数据获取和状态管理的使用

客户端渲染， 异步结合redux流程

1. 创建store
2. 根据路由显示组件
3. 派发action获取数据
4. 更新store的数据
5. 组件Rerender

服务端 页面一旦确认内容就没法重新rerender 了，这就要求组件显示的时候，就要把store 数据准备好，
所以服务端异步数据使用方式流程就是下面
1. 创建 store
2. 根据路由分析store 中需要的数据
3. 派发action获取数据
4. 更新store 中的数据
5. 结合数据生成HTML 一次返回

1.
```
 // 客户端
 const store = createStore(reducer, defaultState)
 export default store
```
如果服务端这么写就存在问题了，因为服务端的store是所有用户共用的， 如果像上面一样创建store store 就是一个单例，所有用户共享store ，这显然是不对的

```
  // 服务端
  const getStore = (req) => {
    return createStore(reducer, defaultState)
  }
  return default getStore
```
2. 
根据路由分析store 中数据， 在服务端首先分析当前路由加载的组件， 这时候我们可以借助一下第三方包 react-router-config
使用这个包传入服务器请求路径，会分析出这个路径下所有组件

3.
 派发action 获取数据， 

 ```
  Home.loadData = (store) => {
  // 负责在服务端渲染之前，把这个路由需要的数据提前加载好
  return store.dispatch(getHomeList())
}
 ```
 这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 
 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了

4.
更新store 中数据 其实在第三部的时候就已经更新完store中的数据了。但是怎么确保在生成HTML之前保证所有数据都获取完毕，这个怎么处理





```
// matchedRoutes 是当前路由对应的所有需要显示的组件集合
matchedRoutes.forEach(item => {
  if (item.route.loadData) {
    const promise = new Promise((resolve, reject) => {
      item.route.loadData(store).then(resolve).catch(resolve);
    })
    promises.push(promise);
  }
})

Promise.all(promises).then(() => {
  // 生成 HTML 逻辑
})
```
这里我们可以使用Promise来解决这个问题，我们构建一个Promise 队列等到所有Promise都执行完后在去生成html

获取数据服务端 和客户端都是使用loadData 因为如果这个页面是你访问的第一个页面那么你的内容就是服务端渲染出来的如果经过react-router 路由跳转到第二个页面，那么这个页面完全是客户端渲染出来的所以客户端也需要拿数据

在客户端拿数据的时候我们最习惯和熟悉的方式就是通过commentDidMount进行数据获取但是需要注意的是componentDidMount只有在客户端才去执行 服务端这个生命周期是不会执行的
这也是为什么数据的获取应该放到 componentDidMount 这个生命周期函数中而不是 componentWillMount 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。


### node 只是一个中间层
node只是一个中间层用来react 代码的服务渲染 node 需要的数据通常由api 服务器单独提供
这样做的目的一个是为了工程解耦 另一个就是为了避免node 服务器的一些计算性能